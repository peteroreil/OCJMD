
Log of all decisions, assumptions, reasoning behind design decisions
====================================================================

Subcontractor class
-------------------
1.	Created a Subcontractor class to be used as a transfer object - Value Object Design Pattern
	For ease of transferring a record or data. Also allows for how params should be set, see point below
	on setting customer ID.
	
2. 	List<String> chosen for specialites, list size will be unknown size.

3. 	Subcontractor Constructor does not take the id of the customer as a parameter. Assuming that 
	if a Subcontractor is being created that there will be no customer to be assigned immediately.
	
4.	The Database Schema specifies and 8 digit number for the customer ID. It is assumed that this
	digit has to be exactly 8 Digits. Setter method setCustomerId throws and IllegalArgumentException
	in event that param is < or > 8 digits.	
	
5.	The setEmployeeCount will throw IllegalArgumentException in event there is less than 0 passed as
	an argument. Does not make sense that an sub-contractor can have negative number employees.
	
6.	Since no key exists in DB and there is no unique identifier for a contractor, such as telephone number,
	Subcontractor equality is based on two attributes: their name and location. If the a contractor of the same name
	works in the same geographic location, we have a problem. These two properties used to generate a hashCode, and are used as the
	recNo Index.
	
	
	

Data class
---------------------------
1.	Constructor allows for setting file path of db location. To cater for multiple locations, client server or stand alone 
	scenario. Using constructor chaining.
	
2. Class is implementing our required interface.

3. Using Facade design pattern to abstract logic from user.

4.	Throwing a custom exception DatabaseException in the event of a FileNotFoundException or IOException. Reasoning if we switch
	DB to non file data source.
	

Database class 
----------------------------
1. Made package private to enforce using Data facade.

2. Added method to retrieve and populate a map of Keys for the Subcontractors and their locations in the database file.
   Method has a boolean flag that will allow dual use of the method. True will populate the record number map (obtaining a write lock)
   and false reading the database file and returning a list only of sub-contractors in the file.
   Using a write lock will ensure no other thread reading or updating at the same time.
   
3. Added a getSubcontractor method which acquires a read lock, allowing for concurrent threads to read from the Map.

4. retreiveSubcontractor seek and readFully are considered atomic hence in synchronized block.
	Do not want any other thread to update while reading from location. Using readFully to ensure that record is fully read - thread not switched out 
	mid read.
	
5. Single data structure Map<Integer, Long>. Where integer is the hashCode of the Subcontractor object
	and Long is the location of the record in the database file.
	
6. persistSubcontractor method, dual purpose, use to update or create a new instance. Decided that there will be no cache implemented. 
   That is, once the Map data structure is updated, the database file will be updated. This will impact on performance as the user will need to 
   acquire a write lock on both the Map (recordLocations variable) and the database file. Any users wishing to read from the database file or from the data structure will
   be blocked until the update/creation is complete. Sacrificing performance for simplicity.
   
8. Using StringBuilder to create New/Updated Record in persistSubcontractor. No internal Synchronization. Increased performance.
	
9. Due to having to create a recNo based on attributes of the object, Have to make a decision on whether 
	i) those attributes can never change
	ii) the index will have to change if those attributes change.

   Have implemented i) if there is an update of the name or location (or both) of the sub-contractor, will throw a DatabaseException.
   Initially implemented option ii) but as I began implementing the locking solution I realised that this was going to cause complexity.
   As Thread-Two could be requesting a lock for a record based on the hash of an existing record. Thread-One updates the composite key 
   fields for the same record, and Thread-Two now wakes and tries to acquire a lock on a record that no longer exists. Has to re-calculate the
   new key based on a read of all records and then try acquire a lock on a new record. 
    


10. Find method, assumed that the find must take a valid record size for its parameters.

 
	
RecordUtility class
--------------------------------
Created a RecordUtility class with two static inner classes for reading and writing from byte arrays